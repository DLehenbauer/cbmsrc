.PAG 'PREFIL'
PREFIL
;
; IF CALLED FORM PRINT
;
	LDA USINGV      ;CHECK BIT#1
	BEQ YESPRT      ;BRANCH IF PRINT CALLED
	JMP NOPRNT      ;ELSE JUMP TO USING LOGIC
.SKI
YESPRT	LDA #21-18      ;ROUND TO...
	JSR BCDRND      ;18 SIGNIFICANT DIGITS
	JSR EXPADJ      ;GET ABS(EXP)
OVRFLO	JSR LSTSIG      ;FIND THE LEAST SIGNIFICANT DIGIT
	BNE IHAVIT      ;BRANCH IF WE HAVE SOMTHING
	LDY #0          ;INDEX INTO OUTPUT BUFFER
	LDA #$20        ;FIRST CHAR IS A BLANK
	STA (INDEX1),Y  ;PUT BLANK INTO OUTPUT BUFFER
	INY             ;NEXT OUTPUT POSITION
ONEZRO	LDA #'0         ;AND AN ASCII ZERO
	STA (INDEX1),Y
	INY             ;NEXT AVAILABLE BYTE FOR END NULL
	PLA             ;DON'T RETURN TO IMMEDIATE CALLER
	PLA             ;RETURN TO CALLER OF CALLER
	RTS             ;RETURN TO FOUT2A
.SKI
IHAVIT
	LDX LASTSG      ;DEFAULT FOR LCOUNT IS LASTSG
	STX LCOUNT      ;SAVE LCOUNT
	LDY #0          ;INIT INDEX INTO OUTPUT BUFFER
	LDA #18         ;DETERMINE IF EXPONENTIAL FORM
	CMP FACEXP      ;IF FACEXP>18 THEN IT IS EXP FORMAT
	BCS NOTXF       ;BRANCH IFF NOT
;
; SET UP EXPONENTIAL DEFAULTS FOR PRINT
;
EXFMT
	LDA #$FF        ;FLAG THIS EXPONENT AS NEGITIVE
	STA UFLAGS+EXPB ;STORE IT IN EXPONENT FLAG BYTE
.SKI
	LDA #1          ;SET DEFAULT FIELD SIZE
	STA LCOUNT
	BNE DORITE      ;BRANCH ALWAYS
.SKI
NOTXF
;
; IF EXPONENT IS <= -3 TTHEN USE EXPONENTIAL FORMAT
;
	LDA EXPSGN      ;TEST TO SEE IF EXPONENT <0
	BPL STDFLD      ;BRANCH IF EXPONENT >=0
.SKI
	STY RCOUNT      ;FLAG NO DECIMAL POINT FROM PUTBUF
;SINCE WE DO IT HERE
	LDX FACEXP      ;IF ABS(EXP)<=2 GOTO STDFFLD
	CPX #2          ;CARRY IS SET IF >2
	BCS EXFMT       ;BRANCH IF ABS(EXP)<=2READY.
	JSR FRSTCH      ;DECIDE WHICH SIGN
	LDX FACEXP      ;GET NUMBER OF LEADING  0'S
NEGEXP	LDA #'.         ;ELSE PRINT AS FRACTION
	STA (INDEX1),Y  ;BEGIN NUMBER WITH A DECIMAL POINT
	INY             ;BUMP OUTPUT BUFFER INDEX
	LDA #'0         ;PAD WITH ANY LEADING 0'S REQUIRED
	JSR PADFIL      ;PUT IN LEADING 0'S
	RTS             ;AND RETURN
.SKI
STDFLD
;
; ESTABLISH STANDARD FORMAT DEFAULTS FOR PRINT
;
	LDX FACEXP      ;LCOUNT=FACEXP+1
	INX             ;DO THE "PLUS 1"
	STX LCOUNT      ;PUT RESULT AWAY FOR LATER
.SKI
DORITE	LDA LASTSG      ;GET LAST SIGNIFICANT DECIMAL PLACE
	SEC             ;IGNORE THE CARRY BIT
	SBC LCOUNT      ;LASTSG-LCOUNT YIELDS RCOUNT
	BPL STORRT
	LDA #0
STORRT
	STA RCOUNT
	BNE FRSENT      ;BRANCH WHEN LASTSG>LCOUNT
	.BYT $AD        ;SKIP THE INC RCOUNT
FRSENT	INC RCOUNT
FRSTCH	LDA #$20        ;DEFAULT SIGN TO PLUS(BLANK)
FIRST2	LDX SGNFLG      ;DETERMINE SIGN OF NUMBER
	BEQ PLSFAC      ;BRANCH IF SIGN >0
	LDA #'-         ;ELSE ITS A MINUS
PLSFAC
	STA (INDEX1),Y  ;PUT SIGN CHARACTER FIRST
	INY             ;BUMP OUTPUT BUFFER INDEX
BYE2	RTS             ;AND RETURN
.SKI
NOPRNT
;
; CALLED BY PRINT USING
;
	LDA #$20        ;SET DEFAULT PREFILL CHARACTER
	LDX UFLAGS+FILLB ;CHECK FOR LEADING STARS
	BEQ PUTIT       ;BRANCH IF NONE
	LDA FILLCH      ;ELSE GET AN ASTERISK
PUTIT	STA FILCHR      ;PUT FILL CHARACTER AWAY
	LDX RCOUNT      ;RCOUNT INCLUDES DP
	STX RCNTSV      ;SAVE IT FOR LATER
	BEQ PRE12
	DEC RCOUNT      ;ROUND WITHOUT DP
PRE12
	DEC LCOUNT      ;FOR SIGN
LNON0	LDA LCOUNT      ;PRESERVE LCOUNT IN...
	STA LCNTSV      ;ZERO PAGE
	JSR SEXTND      ;SIGN EXTEND THE XPONENT
	LDX UFLAGS+EXPB ;CHECK FOR EXP FFORM
	BEQ NEXPON      ;BRANCH IF NON
	LDA RCOUNT
	CLC
	ADC LCOUNT      ;RCOUNT+LCOUNT
	BNE DM21OK      ;GO DO THE ROUNDING
;
; CALCULATE RCOUNT + EXPONENT +1
;
NEXPON	CLC             ;IGNORE THE CARRY
	ADC RCOUNT
	CLC
	ADC #1
	BMI DEF18       ;DEFAULT TO 18 SIGNIFICANT DIGITS IF <0
DM21OK	EOR #$FF        ;1'S COMPLEMENT
	CLC
	ADC #22         ;.A=21-(RCOUNT+EXP+1)
	BMI DEF18       ;BRANCH IF MORE THAN 21 DIGITS
	CMP #3          ;IF .A>= 3 HE'S OK
	BCS DIGTOK      ;BRANCH IF SO
DEF18	LDA #21-18      ;ELSE DEFAULT TO 18 SIGNIFICANT
DIGTOK
	JSR BCDRND      ;ROUND TO HIS SPECS
	JSR SEXTND      ;INCASE HE BUMPED THE EXPONENT
	JSR EXPADJ      ;ADJUST EXPONENT GET SIGN
	LDX RCNTSV      ;CHECK FOR 0 RCOUNT
	CPX #1
	BNE *+3
	INX
	STX RCOUNT
NON0RT
;
; CALCULATE PADDING
;
	LDY #0          ;STARTING INDEX OF OUTPUT BUFFER
	LDA UFLAGS+EXPB ;CHECK IF ANY PADDING IS NEEDED
	BNE FRSTCH      ;BRANCH IF EXPONENTIAL FORMAT
	LDA EXPSGN      ;FIND OUT WHICH SIGN EXPONENT IS
	BEQ EXPLUS      ;BRANCH WHEN EXPONENT IS PLUS
.SKI
	LDX LCOUNT      ;ELSE PADING=LCOUNT
	STX PADING      ;PUT RESULT HERE
	BEQ NOFILL      ;BRANCH IF NO ROOM FOR A SIGN
.SKI
	LDA FILCHR      ;ELSE DO THE PADDING
	JSR PADFIL      ;TELL PADFIL TO DO THE FILLING
NOFILL	JSR SIGNON      ;DO THE SIGN OF THE NUMBER
	LDX PADING      ;SEE IF WE CAN DO A "0."
	DEX             ;DO A DEX RATHER THAN A CPX
	BMI NOLEAD      ;BRANCH IF NO ROOM
.SKI
	LDA #'0         ;ELSE BEGIN WITH THE "0"
	STA (INDEX1),Y  ;PUT IT IN THE OUTPUT BUFFER
	INY             ;BUMP OUTPUT BUFFER INDEX
NOLEAD	LDA RCOUNT      ;CALCULATE RCOUNT-FACEXP
	BNE NOZERO      ;BRANCH IF SOME DIGITS
	JMP ONEZRO      ;ELSE OUTPUT ONLY ONE 0
NOZERO
	LDX FACEXP      ;THIS MANY LEADING 0'S-1
	SEC             ;IGNORE CARRY
	SBC FACEXP
	STA LCOUNT      ;STORE IT ANYWAY...
	BEQ NODIGT      ;BRANCH IF NO DIGITS TO PRINT
	BCS DIGYES      ;BRANCH IF THERE ARE DIGITS
NODIGT	LDX RCOUNT      ;WE WANT RCOUNT DIGITS
DIGYES	JSR NEGEXP      ;DO DP AND LEADING 0'S
	STX RCOUNT      ;TURN OFF DP
	STX UFLAGS+ISCB ;MAKE SURE NO COMMAS
	LDA LCOUNT      ;CHECK TO SEE IF WE ARE DONE
	BEQ IDIDIT
	BPL DIGITS      ;BRANCH IF NOT
IDIDIT	PLA             ;ELSE GET RID OF IMMEDIATE RETURN
	PLA
DIGITS	RTS             ;RETURN TO FOUT2A NOT BCDOUT
.SKI
EXPLUS
;
;FORMAT LOGIC FOR NUMBERS WITH POSITIVE EXPONENET
;
	LDA UFLAGS+ISCB ;CHECK FOR COMMAS IN CALCULATION
	BEQ NOCOMM      ;BRANCH IF NONE
.SKI
	LDA FACEXP      ;ELSE GET EXPONENT FOR ARG TO...
	JSR DIV2ND      ;CALC # OF COMMAS
NOCOMM
	CLC             ;IGNORE CARRY
	ADC FACEXP      ;ADD #COMMAS TO EXPONENT
	ADC #1          ;+1 FOR SIGN AND REFERENCE DP
	STA DPTFLG      ;PUT RESULT HERE FOR NOW
	LDA LCOUNT      ;GET # OF DIGITS FOR LEFT SIDE
	SEC             ;IGNORE CARRY
	SBC DPTFLG      ;LCOUNT-(#COMMAS+EXP+2)
	STA PADING      ;PUT RESULT HERE
	BPL NOVERF      ;BRANCH IF NO OVERFFLOW
.SKI
;
; PUT A "%" AS FIRST CHARACTER OF OUTPUT BUFFER
;
OVRFL	LDA #'%         ;INDICATE OVERFLOW
	STA (INDEX1),Y  ;1ST BYTE OF OUTPUT BUFFER
	STY UFLAGS+ISCB ;PUT A ZERO-TURN OFF COMMAS
	STY USINGV      ;TURN OFF PRINT USING FLAG
	STY RCNTSV
	INC INDEX1      ;NEXT CHARACTER OF OUTPUT
	BEQ BUMPHI      ;BRANCH IF INCREMENT OVERFLOWED
	.BYT $AD        ;SKIP THE INCREMENT
BUMPHI	INC INDEX+1     ;BUMP HIGH ORDER BYTE TOO
	JMP OVRFLO      ;AND JUMP TO PRINT DEFAULTS
.SKI
;
; DECIDE HOW TO PAD THE LEFFT FIELD
;
NOVERF
	LDA FILCHR      ;GET FILL CHARACTER
	LDX PADING      ;GET # OF LEADING NON-DIGITTS
	INX
	JSR PADFIL      ;FILL THE LEADING FIELD
;
; ADJUST LEFT COUNT TO NUMBER OF DIGITS ON LEFT
;
.SKI
	LDX FACEXP      ;LCOUNT=EXPONENT+1
	INX             ;DO THE "+1"
	STX LCOUNT      ;UPDATE NEW LCOUNT
SIGNON
;
;  DETERMINE LEADING SIGN OR '*'
;
	LDA #$20        ;DEFALUT 1ST CHAR IS BLANK
	LDX SGNFLG      ;CHECK SIGN OF NUMBER
	BNE SGNMUS      ;BRANCH IF NEGITIVE #
	LDX UFLAGS+SGPB ;SIGN SHOULD LEAD?
	BEQ NOLSGN      ;BRANCH IF NOT
	LDA #'+         ;ELSE GET A PLUS SIGN
NOLSGN
	LDX UFLAGS+FILLB ;CHECK FOR FILL CHAR
	BEQ PUTCH       ;BRANCH IF NONE
	LDA FILLCH      ;ELSE GET THE FILL CHARACTER
	BNE PUTCH       ;BRANCH ALWAYS
SGNMUS
	BIT UFLAGS+SGMB ;TRAILING MINUS?
	BNE NOLSGN      ;BRANCH IF YES
	BIT UFLAGS+STB  ;TRAILING ANY SIGN?
	BNE NOLSGN      ;BRANCH IF YES
.SKI
	LDA #'-         ;ELSE GET A MINUS SIGN
PUTCH
	LDX UFLAGS+FLTDB ;CURRENCY SIGN?
	BEQ NODOLL      ;BRANCH IF NOT
	LDA MONEY       ;ELSE PUT A $
NODOLL
	STA (INDEX1),Y  ;PUT THE 1ST CHARACTER IN THE OUTPUT
	INY
	RTS
.PAG
