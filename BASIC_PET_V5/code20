.PAG 'CODE20'
MOVFR	LDA RESHO
	STA FACHO
	LDA RESMOH
	STA FACMOH
	LDA RESMO
	STA FACMO
	LDA RESLO
	STA FACLO
	LDA #0          ;"!SET TYPE BINARY
	STA FACTYP      ;!
	JMP NORMAL
;---------------BINARY ONLY--
MOVFM	STA INDEX1
	STY INDEX1+1
MOVFM1	LDY #3+ADDPRC
	LDA (INDEX1)Y
	STA FACLO
	DEY
	LDA (INDEX1)Y
	STA FACMO
	DEY
	LDA (INDEX1)Y
	STA FACMOH
	DEY
	LDA (INDEX1)Y
	STA FACSGN
	ORA #@200
	STA FACHO
	DEY
	LDA (INDEX1)Y
	STA FACEXP
	STY FACOV
	STY FACTYP      ;!SET FACTYPE BINARY
	RTS 
;----------------
;     MOVVF  ---MOVE FAC TO MEM
;       BY TYPE IN FORTYP
;       TO LOC IN FORPNT
;-------------
MOVVF=*
	LDX FORPNT      ;!SET UP POINTER
	LDY FORPNT+1    ;!FOR BIN
	LDA FORTYP      ;!
	JMP MOVMFT      ;!GO TO MOVE BY TYPE
;-------------------
MOV2F	LDX #<TEMPF2    ;!TEMP2 REGIST
	.BYT $2C        ;!SKIP 2 (BIT XXXX)
MOV1F	LDX #<TEMPF1    ;!TEMP1 REG
	LDY #>TEMPF1    ;!MAKE WORK IN ANY PAGE,
;!BUT BOTH MUST BE IN THE SAME PAGE
;-----------------
;   MOVE FAC TO MEMORY BINARY ONLY
;--------------------
MOVMF	STX INDEX1
	STY INDEX1+1
	LDA #0          ;!CONVERT TO BIN
	JSR DCONF       ;!CONVERT FAC TO BIN
MOVMF2	JSR ROUND       ;!ENTRY FROM MOVMFT
	LDY #3+ADDPRC
	LDA FACLO
	STA (INDEX)Y
	DEY
	LDA FACMO
	STA (INDEX)Y
	DEY
	LDA FACMOH
	STA (INDEX)Y
	DEY
	LDA FACSGN
	ORA #@177
	AND FACHO
	STA (INDEX)Y
	DEY
	LDA FACEXP
	STA (INDEX)Y
	STY FACOV
	RTS
;------ARG TO FAC BY TYPE
MOVFA	LDA ARGTYP      ;!GET TYPE
	LSR A
	BEQ MOVFAB      ;!BINARY KEEP OLD FORM
	CMP #1          ;!MUST BE DEC SHIFTED
	BEQ *+5         ;!!CHECK
	JSR ERRORZ      ;!!SYSTEM ?
	LDX #DSIZE-1    ;!SET UP FULL SIZE
MFA1	LDA ARGTYP,X    ;!MOVE IT
	STA FACTYP,X
	DEX             ;!
	BPL MFA1        ;!
	RTS
;----------------
MOVFAB	LDA ARGSGN      ;BINARY
MOVFA1	STA FACSGN      ;!ALT ENTRY
	LDX #4+ADDPRC
MOVFAL	LDA ARGEXP-1,X
	STA FACEXP-1,X
	DEX
	BNE MOVFAL
	STX FACOV
	STX FACTYP      ;!MAKE BINARY
	RTS
;----- FAC TO ARG BY TYPE--
MOVAF	LDA FACTYP      ;!GET TYPE
	LSR A
	BEQ MOVAFB
	CMP #1          ;!!CHECK MUST BE DEC SHIFTED
	BEQ MAF2        ;!OK
	JSR ERRORZ      ;!!BAD STUF
MAF2	LDX #DSIZE      ;!SET UP DEC MOVE
MAF1	LDA FACTYP,X
	STA ARGTYP,X
	DEX
	BPL MAF1
	RTS
;---- BINARY ONLY --
MOVAFB	JSR ROUND
MOVEF	LDX #5+ADDPRC   ;!ALT ENTRY
MOVAFL	LDA FACEXP-1,X
	STA ARGEXP-1,X
	DEX
	BNE MOVAFL
	STX FACOV
	STX ARGTYP      ;!SET BINARY
MOVRTS	RTS
;---- MOVE MEMORY TO STACK BY TYPE----
;X,Y=MEMORY PTR--A=TYPE IN MEMORY
; 'USER FUNCTION CALLS'
;---------------
MOVSMT=*
	STX INDEX2
	STY INDEX2+1
	TAY             ;!SAV IT
	PLA             ;!MAKE RTS INTO JMP (INDEX1)
	STA INDEX1
	PLA
	STA INDEX1+1
	INC INDEX1      ;!MUST BUMP BY 1
	BNE *+4
	INC INDEX1+1
	TYA
	CMP #2          ;LOOK AT TYPE
	BNE MSM2        ;!BINARY?
	LDY #DSIZE-1
MSM1	LDA (INDEX2),Y  ;!LS BYTE FIRST--
	PHA             ;!SHOVE IT
	DEY
	BPL MSM1
	CMP #2          ;!!TEST IT-- LAST SHOULD
	BEQ *+5         ;!BE DEC TYPE
	JSR ERRORZ      ;!!
	JMP (INDEX1)    ;!DO RTS
;-------
MSM2	LSR A           ;!!SHOULD BE BINARY
	BEQ *+5         ;!!
	JSR ERRORZ      ;!!
	LDY #BSIZE-1    ;!PUT ON IN PACKED
MSM3	LDA (INDEX2),Y  ;!LS BYTE FIRST---
	PHA
	DEY
	BPL MSM3
	LDA #$08        ;PUSH PACKED TYPE
	PHA
MSMRET	JMP (INDEX1)    ;!RTS
;--------
;    MOVE FROM STACK TO MEM BY TYP E
;      IN A
;   X,Y=MEM ADDRESS:A=TYPE.
;-------
MOVMST=*
	STX INDEX2      ;!MAKE POINTER
	STA INDEX2+1    ;!FIRST CHECK TYPE
	PLA             ;!MAKE RTS IN INDEX1
	STA INDEX1      ;!FOR JMP ( )
	PLA             ;!
	STA INDEX1+1
	INC INDEX1      ;!RTS IS -1
	BNE MMS2
	INC INDEX1+1
MMS2=*
	PLA             ;!GET STACK TYPE
	PHA             ;!!
	AND #$F7        ;DROP $80 BIT
	CMP INDEX2+1    ;!!SAME AS CALL?
	BEQ *+5         ;!OK
	JSR ERRORZ      ;!!
	STY INDEX2+1    ;REST OF POINTER
	LDY #0
	PLA             ;!GET IT BACK
	CMP #02         ;!IS IT DEC?
	BNE MMS1        ;!BINARY
	LDA (INDEX2),Y  ;!!CHECK SOURCE TYPE FOR SAFETY--
	INY
	CMP #02         ;!!MUST BE INITIALIZED!
	BEQ *+5         ;!!OK
	JSR ERRORZ      ;!!
MMS4	PLA             ;!GET DATA MS BYTE FIRST
	STA (INDEX2),Y
	INY
	CPY #DSIZE      ;!LIMIT
	BMI MMS4
	BPL MMS3        ;!JMP TO RTS
;--
MMS1	CMP #$08        ;!!CHECK TYPE
	BEQ *+5         ;!!!
	JSR ERRORZ      ;!!
MMS5	PLA             ;!GET IT MS BYTE FIRST
	STA (INDEX2),Y
	INY
	CPY #BSIZE      ;!
	BMI MMS5        ;!
MMS3	JMP (INDEX1)    ;!=RTS
;------------------
;  MOVFMT  MOVE MEM TO FAC BY TYPE
;    A,Y=POINTER A,Y=POINTER!!
;    X=TYPE
;------------------
MVFMTI	JMP MOVFM1      ;!INTO BINARY MOVE--
MOVFMT=*
	STA INDEX1
	STY INDEX1+1    ;!
	TXA
	BEQ MVFMTI      ;!INTO BINARY MOVE
	LDY #DSIZE-1
MFMT1	LDA (INDEX1),Y  ;MEMORY
	STA FACTYP,Y
	DEY
	BPL MFMT1
	CMP #2          ;!!LOOK FOR TYPE=2
	BEQ *+5         ;!!
	JSR ERRORZ      ;!!
	RTS
;-------------------
;  MOVE 13 BYTES TO FAC/ARG
;   A,Y= POINTER
;-------------------
MOVA13	SEC             ;!MOVE 13 TO ARG
	BCS MV13X       ;JMP
MOVF13	CLC             ;!MOVE 13 TO FAC
MV13X	STA INDEX1
	STY INDEX1+1
	LDY #DSIZE-1    ;!NOT REALY 13
MV13Z	LDA (INDEX1),Y  ;MEMORY
	BCC MV13W       ;!FOR FAC
	STA ARGTYP,Y    ;!
	BCS MV13Y
MV13W	STA FACTYP,Y
MV13Y	DEY             ;!NO CARRY 'TILL DONE
	BPL MV13Z
	RTS
;---------------
;MOVE MEMORY TO ARG BY TYPE
;  A,Y=MEM LOC----X=TYPE
;----------------
MOVAMT=*
	STA INDEX1
	STY INDEX1+1
	TXA             ;CHK TYPE
	LSR A
	BCS MVAMT3
	BNE MVAMT1      ;!NOT BINART
	JMP CONUPA      ;!DO BINARY
MVAMT3	LDY #0          ;GET INTEGER TYPE
	LDA (INDEX1)Y
	STA ARGHO
	INY
	LDA (INDEX1)Y
	STA ARGMOH
	STY ARGTYP
	LDA #0
	JSR DCONA
	LDA ARGSGN      ;SET SIGN BIT
	EOR FACSGN
	STA ARISGN
	RTS
MVAMT1	CPX #02         ;!!CHECK IT FOR DEC
	BEQ *+5         ;!!MUST BE DEC
	JSR ERRORZ      ;!!
	LDY #DSIZE-1    ;!DO DECIMAL
MVAMT2	LDA (INDEX1),Y  ;!FROM MEM
	STA ARGTYP,Y    ;!TO ARG
	DEY
	BPL MVAMT2
	CMP #2          ;!!CHECK IT
	BEQ *+5         ;!!SHOULD BE DEC IN MEM
	JSR ERRORZ      ;!!
	RTS
;--------------------
;  MOVMFT- MOVE FROM FAC TO MEMORY
;   BY TYPE
;        X,Y=MEMORY LOC;A=MEMORY TYPE
;        WILL CONVERT IF REQUIRED
;---------
MOVMFI	JMP MOVMF2;!INTO BINARY MOVE
MOVMFT=*
	STX INDEX1      ;MAKE POINTER
	STY INDEX1+1
	LDA TARGET
	JSR DCONF       ;!CHECK ALL TYPES
	LDA FACTYP      ;!SAME AS CALL NOW
	LSR A
	BCS MMF3        ;INT HANDLER
	BEQ MOVMFI      ;!BINARY MOVE ++
	CMP #01         ;!! CHECK
	BEQ *+5         ;!!
	JSR ERRORZ      ;!!!
	LDY #0          ;!!TEST
	LDA (INDEX1),Y  ;!!CHECK DESTINATION
	CMP #02         ;!!MUST BE DEC TYPE
	BEQ *+5         ;!!
	JSR ERRORZ      ;!!
	LDY #DSIZE-1    ;!
MMF2	LDA FACTYP,Y    ;!XFER
	STA (INDEX1),Y
	DEY
	BPL MMF2
	RTS
MMF3	LDY #0          ;INTEGER CASE
	LDA FACHO
	STA (INDEX1)Y
	INY
	LDA FACMOH
	STA (INDEX1)Y
	LDA #0          ;CONVERT BACK
	JMP DCONF
;---------
ROUND	LDA FACEXP
	BEQ SIGNRT
	ASL FACOV
	BCC SIGNRT
INCRND	JSR INCFAC
	BNE SIGNRT
	JMP RNDSHF
SIGN	LDA FACTYP
	CMP #2          ;CHK FOR BCD TYPE
	BNE SIGNF
	LDA FACMSD
	BEQ SIGNRT
	LDA FACEXP      ;MOVE SIGN INTO CARRY
	ROR A
	JMP FCOMPQ
SIGNF	LDA FACEXP
	BEQ SIGNRT
FCSIGN	LDA FACSGN
FCOMPS	ROL A
FCOMPQ	LDA #$FF
	BCS SIGNRT
	LDA #1
SIGNRT	RTS
SGN	JSR SIGN
FLOAT	STA FACHO
	LDA #0
	STA FACHO+1
	LDX #@210
FLOATS	LDA FACHO
	EOR #@377
	ROL A
FLOATC	LDA #0
	STA FACLO
	STA FACMO
FLOATB	STX FACEXP
	STA FACOV
	STA FACSGN
	STA FACTYP      ;!SET TYPE BINARY
	JMP FADFLT
;
ABS	LDA FACTYP      ;DETERMINE TYPE
	LSR A
	BEQ ABS1
	LSR FACEXP      ;DECIMAL ABS
	ASL FACEXP
	RTS
ABS1	LSR FACSGN      ;BIN & INT ABS
	RTS
;
FCOMP	STA INDEX2
FCOMPN	STY INDEX2+1
	LDY #0
	LDA (INDEX2)Y
	INY
	TAX
	BEQ SIGN
	LDA (INDEX2)Y
	EOR FACSGN
	BMI FCSIGN
	CPX FACEXP
	BNE FCOMPC
	LDA (INDEX2)Y
	ORA #$80
	CMP FACHO
	BNE FCOMPC
	INY
	LDA (INDEX2)Y
	CMP FACMOH
	BNE FCOMPC
	INY
	LDA (INDEX2)Y
	CMP FACMO
	BNE FCOMPC
	INY
	LDA #$3F
	CMP FACOV
	LDA (INDEX2)Y
	SBC FACLO
	BEQ QINTRT
FCOMPC	LDA FACSGN
	BCC FCOMPD
	EOR #$FF
FCOMPD	JMP FCOMPS
.END
