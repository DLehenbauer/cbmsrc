.PAGE 'DOS PARSER'
;******* DOSPAR **************
;*
;*       -MGM 7/23/79-
;*
;* THIS IS THE PARSER ROUTINE
;* IT LOOKS AT LINES PASSED TO
;* IT AND MAKES SURE THAT THE
;* SYNTAX IS ALL PROPER.
;*
;* IT RETURNS WITH PARCHK
;* IN THE .ACC
;*
;* PARCHK IS THE
;*   "PARSING CHECK BYTE".
;* FLAGS ARE SET ACCORDINGLY
;* AS VALUES ARE PARSED  AND SET
;*
;* STRUCTURE OF PARCHK:
;*
;*I-I-I-I-I-I-I-I-I
;*I7+6+5+4+3+2+1+0I
;*I-I-I-I-I-I-I-I-I
;* ^ ^ ^ ^ ^ ^ ^ ^=> FN1: THIS  BIT
;* ! ! ! ! ! ! !   IS SET WHEN THE FIRST
;* ! ! ! ! ! ! !   FILENAME IS PARSED
;* ! ! ! ! ! ! !=> FN2: " FOR SECOND FILENAME
;* ! ! ! ! ! !=> LA: BIT SET WHEN #L IS PARSED
;* ! ! ! ! !=> FA: BIT SET WHEN UNIT# IS PARSED
;* ! ! ! !=> D1: BIT SET WHEN DRIVE1 PARSED
;* ! ! !=> D2: DITTO - WHEN DRIVE2 PARSED
;* ! !=> LRECL: SET WHEN LRECL PARSED
;* !=> @RPL: SET ON REPLCMNT OPERATOR IN FN1
;*
;*  THE FOLLOWING ARE THE VALID BIT-
;*     PATTERNS FOR PARCHK AFTER PARSING
;*   FOR THE VARIOUS KEYWORDS:
;*
;*             PARCHK
;*          7 6 5 4   3 2 1 0
;*(FORMAT)
;* HEADER   0 0 0 1   * 0 0 1
;* COLECT   0 0 0 *   * 0 0 0
;* BACKUP   0 0 1 1   * 0 0 0
;* COPY     0 0 1 1   * 0 0 0
;*   OR..   0 0 * *   * 0 1 1
;* CONCAT   0 0 * *   * 0 1 1
;* DSAVE    * 0 0 *   * 0 0 1
;* DLOAD    0 0 0 *   * 0 0 1
;* CATLOG   0 0 0 *   * 0 0 *
;* RENAME   0 0 0 *   * 0 1 1
;* APPEND   0 0 0 *   * 1 0 1
;* SCRTCH   0 0 0 *   * 0 0 1
;* DOPEN    * * 0 *   * 1 0 1
;* DCLOSE   0 0 0 0   * * 0 0
;*          ^ ^ ^ ^   ^ ^ ^ ^
;*          @ L D D   F L F F
;*          R R 2 1   A A N N
;*          P E           2 1
;*          L L
;*   "1" BITS ARE REQ'D PARAMETERS
;*   "*" BITS ARE OPTIONAL PARMS
;************************************
;
DOSPAR	LDA #0
	LDX #6          ;CLR 7 BYTES
DOS000	STA FNLEN2,X    ;CLEAR DISK GUYS
	DEX
	BPL DOS000
	STA LA
	STA FNLEN
	LDX #8
	STX FA
	JSR CHRGOT      ; GET CURRENT CHR
	BEQ DONE1       ; <CR> OR <:> => DONE
;
PARSE1	CMP #'#
	BEQ LOGADR
	CMP #'W
	BEQ RECLEN
	CMP #'L
	BEQ RECLEN
	CMP #'R
	BEQ PARRED
	CMP #'D
	BEQ DRV1
	CMP #ONTK       ;"ON" TOKEN
	BEQ ON1
	CMP #'U
	BEQ UNIT1
	CMP #'I
	BEQ IDENT
NEXT7	CMP #'"
	BEQ NAME11
	CMP #'(
	BEQ NAME11
SNER1	JMP SNERR       ;SNYTAX ERROR
PARRED	JMP PARREZ      ;,R CASE
;
LOGADR	LDA PARCHK      ;CHK SYNTAX
	AND #4
	BNE SNER1       ;ONLY ONE LA ALLOWED
	JSR GETVAL
	TXA             ;SET FLAGS
	BEQ QTYER2      ;ZERO NOT ALLOWED
	STX LA
	LDA #4          ;SET LA FLAG &
	BNE DRVDLM
;
RECLEN	TAX             ;SAVE CHAR
	LDA PARCHK      ;CHK SYNTAX
	AND #$40
	BNE SNER1       ;ONLY 1 LRECL ALLOWED
	CPX #'W
	BNE RECOO
	JSR CHRGET      ;SOAK UP W
	JMP RECON
RECOO	JSR GETVAL
	TXA             ;SET FLAGS
	BEQ QTYER2      ;ZERO ILLEGAL LRECL
	INX             ;CPX #$FF
	BEQ QTYER2      ;ILLEGAL LRECL
	STA LRECL       ;STORE PARCEL
RECON	LDA #$40        ;SET LRECL FLAG
	BNE DRVDLM
;
DONE1	JMP DONE
;
NAME11	JMP NAME1
ON1	JSR ON
	BNE DELIMG
UNIT1	JSR UNIT        ;DO UNIT# PARSING
DELIMG	JMP DELIM1
;
;
DRV1	LDA PARCHK
	AND #$10
	BNE SNER1       ;DRIVE1 ALLOWED ONCE
	JSR GETVAL
	CPX #2
	BCS QTYER2      ;ILLEGAL DRV# IF >1
	STX DRIVE1
	STX DRIVE2
	LDA #$10        ;SET DRIVE1 FLAG
DRVDLM	BNE DELSP
;
QTYER2	JMP QTYERR
;
IDENT	LDA DIDCHK
	BNE SNER1       ;ONLY 1 DISKID ALLOWED
IDCON	JSR CHRGET      ;CHECK FOR (
	CMP #'(         ;NEW OR OLD?
	BEQ IDDNEW
IDDOLD	LDX TXTPTR      ;GET OLD TWO CHAR ID
	LDY TXTPTR+1
	JSR CHRGET      ;TOSS  CHAR
	STX INDEX
	STY INDEX+1
	JMP IDDN00      ;BRA
IDDNEW	JSR NEWNAM      ;GET STRING
	LSR A
	BEQ SNER2       ;MUST BE >1 CHAR
IDDN00	LDY #1          ;GET FIRST TWO CHARS
IDDN01	LDA (INDEX)Y
	BEQ SNER2
	STA DISKID,Y
	DEY
	BPL IDDN01
PARREZ	JSR CHRGET
	JMP DELIM1
;
NAME1	LDA PARCHK
	AND #1          ;NAME1 ALLWD ONLY ONCE
	JSR NEWNAM      ;DO NAME PARSING
	STA FNLEN
	STA COUNT0      ;SAVE TEMP VALUE
	LDA #<TBUF2
	STA FNADR
	LDA #>TBUF2
	STA FNADR+1;RESET FNADR VALUE
	LDY #0
LOOP6	LDA (INDEX1)Y   ;TBUF2 XFER LOOP
	CPY #0
	BNE NAMCON
	CMP #'@
	BNE NAMCON
	INC FNADR       ;AND ERASE IT
	DEC FNLEN
NAMCON	STA TBUF2,Y
	INY
	CPY COUNT0
	BCC LOOP6
	LDA #1          ;SET NAME1 FLAG
DELSP	JSR SETPAR      ;SET PARCHK
;
DELIM1	JSR CHRGOT
	BNE *+5
	JMP DONE1       ;<CR>/<:>  => DONE
	CMP #',
	BNE NEXT6
	JSR CHRGET
	JMP PARSE1
NEXT6	CMP #ONTK
	BNE *+5
	JMP ON1
	CMP #TOTK       ;"TO" TOKEN
	BNE SNER2
;
;
PARSE2	JSR CHRGET
	CMP #'D
	BEQ DRV2
	CMP #ONTK       ;"ON" TOKEN
	BEQ ON2
	CMP #'U
	BEQ UNIT2
	CMP #'"
	BEQ NAME2
	CMP #'(
	BEQ NAME2
SNER2	JMP SNERR       ;ERROR
;
;
DRV2	LDA PARCHK
	AND #$20
	BNE SNER2       ;ONLY ONE DRIVE2 ALLWD
	JSR GETVAL
	CPX #2
	BCS QTYERR      ;ILLEGAL DRIVE #
	STX DRIVE2
	LDA #$20        ;SET DRIVE2 FLAG
	BNE NAMDLM
;
;
ON2	JSR ON
	BNE DELIM2
UNIT2	JSR UNIT        ;DO UNIT# PARSING
	BNE DELIM2
;
;
NAME2	LDA PARCHK
	AND #2          ;NAME2 ALLOWED ONLY ONCE
	JSR NEWNAM
	STA FNLEN2
	STX FNADR2
	STY FNADR2+1
	LDA #2          ;SET FILENAME2 FLAG
NAMDLM	JSR SETPAR      ;SET FLAGS
;
DELIM2	JSR CHRGOT
	BEQ DONE        ;DONE ON <CR>/<:>
	CMP #',
	BEQ PARSE2
	CMP #ONTK       ;"ON" TOKEN
	BEQ ON2
	CMP #'U
	BEQ UNIT2
SNER3	JMP SNERR       ;ERROR
;
;
DONE	LDA PARCHK      ;LOAD PARSER CHK
	RTS             ;BYTE FOR CALLING PROG TO CHECK
;
;**************************************
;* DOSPAR SUPPORT ROUTINES            *
;**************************************
;
;
QTYERR	LDX #ERRFC
	JMP ERROR;"ILLEGAL QUANTITY"
;
;
ON	JSR CHRGET
	CMP #'U
	BNE SNER3       ;NXT CHR MUST BE "U"
UNIT	JSR GETVAL
	CPX #32
	BCS QTYERR      ;ERROR IF >31
	CPX #3
	BCC QTYERR      ;ERROR IF <3
	STX FA
	LDA #8          ;SET UNIT# FLAG
	BNE SETPAR      ;JMP SETPAR
;
NEWNAM	BNE SNER3
	JSR FRMEVL
	JSR FRESTR
	TAX             ;SAVE LENGTH IN .X
	BEQ QTYERR      ;0 LENGTH NOT ALLOWED
	CMP #18
	BCS ERRLEN
	LDY #0
	LDA (INDEX1)Y
	CMP #'@
	BNE LENCHK
	BIT PARCHK
	BPL NXXT5       ;IF T>= THEN ERROR
	BMI SNER3
LENCHK	CPX #17         ;"STRING TOO LONG ?
	BCC NEXT5
ERRLEN	LDX #ERRLS
	JMP ERROR       ;"STRING TOO LONG"
NXXT5	LDA #$80        ;SET "@" FLAG
	JSR SETPAR
NEXT5	TXA             ;.A = FNLEN NOW
	LDX INDEX1
	LDY INDEX1+1
	RTS
;
;
GETVAL	;GET NEXTVALUE ROUTINE
	JSR CHRGET      ;GET NXT CHR
GTVL2	BEQ SNER3       ;CANT BE <CR>/<:>
	BCC NUMERC      ;CAN BE NUMERIC
	JSR CHKOPN      ;OR A "("
	JSR GETBYT      ;ANYTHING ELSE IS AN ERROR
	JMP CHKCLS      ;NEED CLOSING ")"
NUMERC	JMP GETBYT      ;EVALUATE IT
;
SETPAR	ORA PARCHK      ;SET BIT(S)
	STA PARCHK
	RTS
;
CKSUMD	.BYT 0          ; D-PAGE CHECKSUM BYT
.END
