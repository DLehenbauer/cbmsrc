.PAGE 'PRINT USING'
;
; USGHDL - PRINT USING ROUTINE  RSR 2/14/80
;
USGHDL	JSR CHRGET      ;DUMP USING TOKEN
	LDA #<USINGV    ;WANT STRING IN
	LDY #>USINGV    ; PRINT USING POINTER
	LDX #$FF
	STX VALTYP      ;SET UP FOR STRING
	STX IDX         ;SET UP POINTER INDEX
	STX PTMP1       ;TEMP FOR CHAR ONLY CASE
	STX PTMP2       ;TEM FLAG FOR NO TRAILERS
	JSR LET3        ;USE LET CODE TO ASSIGN
	LDA USINGV      ;MUST HAVE GOT A STRING
	BEQ USGPER      ;OR IT'S AN SYNTAX ERROR
;
USGPA	LSR PTMP1       ;SHIFT SO FIRST TIME ON
	JSR CHRGOT
	BEQ USGRTN      ;IF NOT(EOL) THEN
	CMP #'; ; MUST BE SEPERTED
	BEQ USGPB
	CMP #',         ;  BY A ; OR A ,
	BEQ USGPB
USGPER	JMP SNERR
;
USGPB	JSR CHRGET      ;DUMP SEPERATOR
	BEQ USGRTZ      ;IF ;NULL THEN NO TRAILING C/R
	LDA #$F0        ;RESET TARGET
	STA TARGET
	JSR FRMEVL      ;EVAL EQUATION
	JMP USGPAR      ;PARSE ASSOCIATE STRING
;
USGRTN	JSR USGRTZ      ;CLR UP
	JMP CRDO        ;TERMINATE WITH C/R
;
USGRTZ	STA PTMP2       ;.A=0 TO GET HERE QUIT ON SYMBOL
	JSR USGPAR      ;FINISH STRING
USGRTE	JSR USGMOV      ;MOVE TO INDEX3
	LDY USINGV      ;GET LENGTH
	BEQ USGRTF      ;NOTASSIGNED!?!
	TYA             ;GARBAGE STRING
	STA (INDEX3)Y
	LDA #$FF
	INY
	STA (INDEX3)Y
	LDA #0
	STA USINGV      ;DONE WITH THIS STRING
USGRTF	RTS
;
.PAG 'USING PARSE'
;
; PRINT USING STRING PARSER - RSR 2/12/80
;
; INPUTS - STRING POINTER IN USINGV
;        - IDX AT PARSE OFFSET IN STRING
;        - OIDX AT OLD PARSE OFFSET IN STRING
; OUTPUT - INFORMATION ABOUT STRING OR NUMBER FORMAT
;        - LCOUNT IS DIGITS TO LEFT OF DP
;        - RCOUNT IS DIGITS TO RIGHT OF DP
;        - UFLAGS CONTAINS BIT FLAGS FOR FOUT
;
SWTB	=7 ;SIGNWILLTRAIL*BIT
DPB	=8 ;DECIMALP*BIT
;
FILLB	=0 ;FILL**BIT
FLTDB	=1 ;FLOAT$*BIT
ISCB	=2 ;INSERT,*BIT
EXPB	=3 ;EXPONENT*BIT
SGPB	=4 ;SIGN+*BIT
SGMB	=5 ;SIGN-*BIT
STB	=6 ;SIGNTRAIL*BIT
RPCSYM	=$2F            ; '/
;
;
USGPAR	JSR USGMOV      ;BEGIN[ INDEX3:=USING VECTOR
	JSR CLRARG      ;CLR THE ARG FOR FLAGS
	LDX #$FF        ; OLDINDEX := -1
	STX OIDX
	CPX IDX         ; IF RESTART LINE
	BNE USG005
	BIT PTMP2       ;  AND CLEAN UP
	BVC USG036      ;RETURN!
USG005	JSR USGGET      ; CHAR:=CHARGET
;
USGENT	LDX IDX         ;IF OLDINDEX=INDEX
	CPX OIDX
	BNE USG010
USGOUA	BIT UFLAGS+SWTB ; THEN  IF FLAGS.SIGNWILLTRAIL*BIT
	BVC USGOUT      ;  ELSE OUTPUT(CHAR)
	JMP SEXNUM      ;  THEN SYSEXIT*NUM
USGOUT	JSR OUTDO       ;OUTPUT(.A)
	JSR USGGET      ;CHAR := CHARGET
;
USG010	LDX IDX         ;OLDINDEX:=INDEX
	STX OIDX
;
USG015	BIT UFLAGS+SWTB ;THEN
	BVS USG050      ; IF FLAGS.SIGNWILLTRAIL*BIT THEN CHK NUMBERS ONLY
;
USG020	CMP #'%         ;IF CHAR ='%'
	BNE USG030
USG021	INC RCOUNT      ;  LOOP RIGHT:=RIGHT+1
	JSR USGGET      ;  CHAR:=CHARGET
	CMP #'%         ;  IF CHAR='%'
	BEQ SEXSTR      ;    THEN SYSEXIT*STR
	CMP #$20        ;UNTILL CHAR<>SPACE
	BEQ USG021
SEXFER	JMP SNERR       ;SYSEXIT*FORMATERROR
;
USG030	CMP #'!         ;IF CHAR='!'
	BNE USG040
SEXSTR	INC RCOUNT      ;  THEN SYSEXIT*STR
SEXFTR	LDX #DPB        ;IF ANYFLAGS SET THEN ERROR
USG032	LDA UFLAGS,X
	BNE SEXFER
	DEX
	BPL USG032
	JSR USGGET      ;CHK FOR END
	BNE USG034
	STA IDX         ;INDEX:=1
USG034	DEC IDX         ;INDEX:=INDEX-1
	BIT PTMP2       ;END CASE?
	BVC USG036
	CPX VALTYP      ;CHK TO MAKE SURE WE HAVE STRING
	BNE SEXFER      ;NO THEN ERROR
	JSR STRPRT      ;ELSE PRINT STRING
	JMP USGPA       ;BACK TO PRINT LOOP
USG036	RTS
;
USG040	CMP #'&         ;IF CHAR='&'
	BEQ SEXFTR      ; THEN SYSEXIT*FSTR
;
USG045	CMP #RPCSYM     ;IF CHAR=REPLACSYM THEN
	BNE USG050
	BIT UFLAGS+SWTB ; IF FLAGS.SIGNWILLTRAIL*BIT THEN
	BVS USG052
	LDX #3          ;FOR I=4 TO 1 STEP -1
USG046	JSR USGGET      ;  CHAR:=CHARGET
	BEQ SEXFER      ;  IF CHAR=NULL THEN ERROR
	STA PUDEFS,X    ;SET USER*DEFINES
	DEX
	BPL USG046      ;NEXT I
USG047	JSR USGGET
;
USG050	AND #$FF        ;IF CHAR=NULL
	BNE USG060
	STA IDX         ; THEN [ INDEX:=0
	LDX UFLAGS+SWTB ;  IF FLAGS.SIGNWILL TRAIL*BIT
	BNE USG052      ;   THEN SYSEXIT*NUM
	BIT PTMP1       ;  IF FIRST PASS AND NO VALID SYMBOL
	BVS USG054      ;   THEN END PRINT
	LDX PTMP2       ;   IF LAST PASS THEN RETURN
	BEQ USG036
	DEC IDX         ;   ELSE INDEX:=INDEX-1:CONTINUE
	BNE USG047      ;BRA
USG052	JMP SEXNUM      ;  ELSE SYSEXIT*NUM ]
USG054	JMP USGRTE
;
USG060	CMP #'@         ;IF CHAR='@'
	BNE USG070
	BIT UFLAGS+SWTB ;CHK FOR PREVIOUS NUMBER INFO
	BVS USG085      ;IF SOME THEN QUIT
	JSR USGGET      ; THEN [CHAR:=CHARGET
	BEQ SEXFER      ;  IF CHAR=NULL THEN SYSEXIT*FORMATERROR
	BNE USG085      ;  ELSE [OUTPUT(CHAR) CHAR:=CHARGET ]]
;
USG070	CMP #'*         ;IF CHAR='*'
	BNE USG080
	JSR USGGET      ; THEN [CHAR:=CHARGET
	CMP #'*         ; IF CHAR<>'*'
	BNE USG104      ;  THEN SYSEXIT*FORMATERROR
	INC LCOUNT      ;  ELSE [
	INC LCOUNT      ;   LEFT:=LEFT+2
	LDX #FILLB      ;   CHK&SET(FILL**BIT)
	JSR CASB
	JSR USGGET      ;   CHAR:=CHARGET
	CMP #'$         ;   IF CHAR='$' THEN CHAR$*SET
	BNE USGWTS
USGFLD	LDX #FLTDB      ;CHAR$*SET BEGIN
	JSR CASB        ; CHK&SET(FLOAT$*BIT)
	INC LCOUNT      ; LEFT:=LEFT+1
USGWTG	JSR USGGET      ; CHAR:=CHARGET
USGWTS	LDX #$FF        ; SET*FLAG(SIGNWILLTRAIL*BIT)
	STX UFLAGS+SWTB
;
USG080	CMP #'$         ;IF CHAR='$'
	BNE USG090
	INC LCOUNT      ;LEFT:=LEFT+1
	JSR USGGET      ; THEN [CHAR:=CHARGET
	CMP #'$         ;  IF CHAR='$' THEN CHAR$*SET
	BEQ USGFLD
	DEC IDX         ;BACK UP INDEX
	DEC LCOUNT      ;BACK UP LEFT BY ONE
	LDA MONEY       ;  ELSE OUTPUT('$')]
USG085	JMP USGOUA
;
USG090	LDA USGCHR      ;IF CHAR=','
	CMP #',
	BNE USG100
	LDX #ISCB       ; THEN [
	JSR CASB        ;  CHK&SET(INSERT,*BIT)
	LDX UFLAGS+DPB
	BNE USG104      ;  CHK*FLAG(DECIMALP*BIT)
	JSR USGGET      ;  CHAR:=CHARGET ]
;
USG100	CMP #'#         ;IF CHAR='#'
	BNE USG110
	BIT UFLAGS+DPB  ; THEN [ IF FLAGS.DECIMALP*BIT
	BVC USG102
	INC RCOUNT      ;   THEN RIGHT:=RIGHT+1
	BNE USG103
USG102	INC LCOUNT      ;   ELSE LEFT:=LEFT+1
USG103	CLC             ;  IF RIGHT+LEFT<25
	LDA RCOUNT
	ADC LCOUNT
	CMP #25
	BCC USGWTG      ;   THEN CHAR:=CHARGET
USG104	JMP SEXFER      ;   ELSE SYSEXIT*FORMATERROR
;
USG110	CMP #'.         ;IF CHAR='.'
	BNE USG120
	LDX #DPB        ;  CHK&SET(DECIMALP*BIT)
	JSR CASB
	INC RCOUNT      ; RIGHT:=RIGHT+1
	JSR USGGET      ;  CHAR:=CHARGET ]
;
USG120	CMP #'^         ;IF CHAR='^'
	BNE USG130
	LDX #0          ; THEN LOOP
USG122	INX             ;  COUNT:=COUNT+1
	JSR USGGET      ;  CHAR:=CHARGET
	CMP #'^         ; UNTILL CHAR<>'^'
	BEQ USG122
	CPX #4          ; IF X<>4 THEN SYSEXIT*FORMATERROR
	BNE USG104
	LDX #EXPB       ; CHK&SET(EXP*BIT)
	JSR CASB
;
USG130	CMP #'+         ;IF CHAR='+'
	BNE USG140
	BIT UFLAGS+SWTB ; THEN [
	BVC USG132      ;  IF FLAGS.SIGNWILLTRAIL*BIT
	LDX #STB        ;   THEN SET*FLAGS(SIGNTRAIL*BIT)
	JSR CASB
	LDX UFLAGS+SGPB ;NO PREVIOUS + SIGN?
	BNE USG104
	BEQ USG134      ;BRA
USG132	LDX #SGPB       ;   ELSE CHK&SET*FLAGS(SIGN+*BIT)
	JSR CASB
	INC LCOUNT
USG134	JSR USGGET
;
USG140	CMP #'-         ;IF CHAR='-'
	BNE USG150
	BIT UFLAGS+SWTB ;IF FLAGS.SIGNWILL TRAIL*BIT
	BVC CHKERS      ; THEN SYNTAX ERROR
	LDX #SGMB       ; THEN [
	JSR CASB        ;  CHK&SET(SIGN-*BIT)
	LDA UFLAGS+SGPB
	ORA UFLAGS+STB
	BNE CHKERS
	JSR USGGET      ;  CHAR:=CHARGET ]
	BEQ USG150
;
SEXNUM	DEC IDX         ;SYSEXIT*NUM BEGIN INDEX:=INDEX-1
	BIT PTMP2       ;TEST FOR END CASE?
	BVC CHKB1       ;RTS
USGZ01	LDX VALTYP
	INX
	BEQ USG104      ;TYPE IS STRING =>ERROR
	JSR FOUT2A      ;OUTPUT NUMBER
	JSR STRLIT
	LDA #0          ;CLR RCOUNT SO ALL OF STRING GOES OUT
	STA RCOUNT
	JSR STRPRT
	JMP USGPA       ;BACK INTO PRINT LOOP
;
USG150	JMP USGENT      ;UNTILL 0=1
;
; USGGET - CHARGET * GETS NEXT CHAR IN USING STRING
;           RETURNS CHAR IN USGCHR AND .A
;
USGGET	INC IDX         ;CHARGET FUNC BEGIN [ INDEX:=INDEX+1
	LDA #0          ;IF DONE THEN RETURN ZERO
	LDY IDX
	CPY USINGV      ;TEST FOR END
	BCS USGGA
	LDA (INDEX3)Y   ; RETURN(USING.STR(INDEX))
USGGA	STA USGCHR
	RTS
;
; CASB - CHK&SET() * CALLS CHKB GIVES ERROR OR SETS BIT
; SETB - SET*FLAG() * SET BIT
;
CASB	LDY UFLAGS,X
	BNE CHKERS
SETB	LDY #$FF
	STY UFLAGS,X
CHKB1	RTS
CHKERS	JMP SEXFER      ;ALREADY SET IS FORMAT ERROR
;
USGMOV	LDY USINGV+1    ;INDEX3 :=USING VECTOR
	STY INDEX3
	LDY USINGV+2
	STY INDEX3+1    ;]
	RTS
;
CLRARG	LDA #0          ;CLR VARS AND FLAGS
	LDX #13         ;...CLR ARG
CLRAR1	STA ARGTYP,X
	DEX
	BPL CLRAR1
	RTS
.END
